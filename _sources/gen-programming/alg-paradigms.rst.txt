*********************
Algorithmic Paradigms
*********************

Algorithmic paradigms refer to fundamental approaches, strategies, or
methodologies used in the design and analysis of algorithms. These paradigms
provide high-level templates or frameworks for solving various types of
computational problems. They help algorithm designers make informed choices
about how to structure and optimize algorithms based on the nature of the
problem at hand.

Common Paradigms
================
+ Brute force:

  Brute-force algorithms solve problems by exhaustively searching through all
  possible solutions without exploiting any problem structure or patterns. They
  are simple to implement and are guaranteed to find a solution if it exists,
  but they are often computationally expensive and impractical for real-world
  problems.

+ Divide and Conquer:

  This paradigm involves breaking down a complex problem into smaller, more
  manageable subproblems, solving them independently, and then combining their
  solutions to obtain the final result. The merge sort and quick sort algorithms
  are classic examples of divide-and-conquer algorithms.

+ Greedy Algorithms:

  Greedy algorithms make a series of locally optimal choices at each step in
  the hope of finding a globally optimal solution. They are often used in
  optimization problems where you want to maximize or minimize a certain value,
  such as the greedy algorithm for the coin change problem.

+ Dynamic Programming:

  Dynamic programming is used to solve problems that can be broken down into
  overlapping subproblems. It involves solving and caching the solutions to
  these subproblems to avoid redundant calculations. Classic examples include
  the Fibonacci sequence and the Knapsack problem.

+ Backtracking:

  Backtracking is a technique used to solve problems incrementally by trying
  out different possibilities and undoing them if they don't lead to a valid
  solution. It is commonly used in problems like the N-Queens problem and
  Sudoku solving.

+ Randomized Algorithms:

  Randomized algorithms make use of randomness to solve problems. They often
  involve probabilistic choices and are used in situations where finding a
  deterministic solution is challenging or computationally expensive. Examples
  include the Monte Carlo method and randomized quick sort.

+ Linear Programming:

  Linear programming is a mathematical optimization technique used to find the
  best outcome in a mathematical model with linear relationships. It is
  commonly used in operations research and resource allocation problems.

+ Branch and Bound:

  This paradigm is typically used for solving optimization problems. It
  involves breaking down the problem into a tree of subproblems, bounding the
  possible solutions, and pruning branches that cannot lead to better
  solutions. The traveling salesman problem can be solved using branch and
  bound.

+ Parallel and Distributed Algorithms:

  These algorithms are designed to run on parallel computing architectures and
  distributed systems. They focus on efficiently utilizing multiple processors
  or machines to solve problems more quickly.

+ Heuristic Algorithms:

  Heuristic algorithms provide approximate solutions to complex problems when
  finding an exact solution is impractical or time-consuming. Examples include
  genetic algorithms and simulated annealing.

+ Graph Algorithms:

  Graph algorithms are specialized paradigms for solving problems related to
  graphs and networks. Common examples include depth-first search,
  breadth-first search, and Dijkstra's algorithm for shortest paths.

These algorithmic paradigms are not mutually exclusive, and many algorithms may
combine multiple approaches to solve real-world problems efficiently. The
choice of which paradigm to use depends on the specific problem requirements,
constraints, and the trade-offs between factors like time complexity, space
complexity, and accuracy.

Types of problems
=================
+ Find optimal/near-optimal solution - optimization

  * brute-force
  * greedy
  * dynamic programming
  * branch and bound
  * linear programming
  * heuristic algorithms

+ Find any solution - search

  * brute-force
  * backtracking
  * randomized

+ Find all solutions - enumeration

  * brute-force
  * backtracking

Determinism
===========
+ Deterministic algorithms
+ Non-deterministic algorithms

  * randomized algorithms
  * heuristic algorithms that use randomness

Accuracy
========
+ Exact algorithms
+ Approximation algorithms
