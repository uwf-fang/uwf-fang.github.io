.. highlight:: c++
  :linenothreshold: 5

****************************
Memory Management in Classes
****************************

Dynamic data in class
=====================

+ pointer-typed instance variables

  * holding a single value or an array
  * allocated using ``new`` or passed in as parameters

+ Potential memory problems

  * memory leak - fail to ``delete``

    - bad or no destructor

  * shallow copy - fail to copy the dynamic data in the heap memory

    - only the memory address are copied by default constructor/assignment
    - bad or no copy constructor
    - bad or no copy assignment operator overload
    - **may not be a problem if objects are never copied or copy assigned**
    - will consequently cause the destructor to ``delete`` a same memory
      block in heap multiple times

+ Rule of three

  * The **big three** methods needed for classes with dynamic data.
  * destructor

    - **mandatory** because it will always be triggered
    - when an object is destroyed

      * local object going out of scope
      * dynamic object being ``delete`` d

    - place to ``delete`` dynamic data

  * copy constructor

    - explicit triggering ``MyClass obj1; MyClass obj2(obj1);``
    - implicit triggering

      + in initialization
      + ``MyClass obj1; MyClass obj2 = obj1;``

    - place to perform deep copy

  * copy assignment operator overload

    - triggering ``MyClass obj1; MyClass obj2; obj2 = obj1;``
    - implicit assignment

      + parameter passing by value
      + return as value

    - clean up old data
    - perform deep copy
    - ``return *this;``

  * you may omit the last two if they are never triggered (not recommended)

::

  class MyClass {
   private:
    int *arr;
    int size;
   public:
    MyClass();
    MyClass(int size);
    MyClass(const MyClass& other);
    MyClass & operator=(const MyClass& other);
    ~MyClass();
  }

  MyClass::MyClass() {
    size = 0;
    arr = nullptr;
  }

  MyClass::MyClass(int size) {
    this->size = size;
    arr = new int[size];
  }

  MyClass::MyClass(const MyClass& other) {
    // you can access private member of other directly!
    size = other.size;
    arr = new int[size];
    for (int i = 0; i < size; i++)
      arr[i] = other.arr[i];
  }

  MyClass & MyClass::operator=(const MyClass& other) {
    size = other.size;
    // must release memory of the old dynamic data first!
    if (arr != nullptr)
      delete [] arr;
    arr = new int[size];
    for (int i=0; i<size; i++)
      arr[i] = other.arr[i];
    return *this;  // IMPORTANT! return the current object by reference
  }

  ~MyClass::MyClass() {
    delete [] arr;
  }

Ownership of Dynamic Data
=========================

A dynamic data can be created and passed. As the ownership changed. The last
owner should take the responsibility to release the memory.

::

  class DataType {
    // ...
  };

  class MyClass {
   private:
    DataType *myDynamicData;
   public:
    MyClass(DataType *initialData = nullptr) {
      myDynamicData = initialData;
    }
    ~MyClass() {
      // delete here although it is not new'ed in the class
      delete myDynamicData;
    }
  };

  int main() {
    DataType *initData = new DataType();  // main function owns it
    MyClass obj1(initData);  // obj1 owns it now

    return 0;
  }

You can also choose to remove the destructor and let the main function to delete
initData. The method using destructor usually works better in more complex projects.
