**************************************
Backtracking and Exhaustive Algorithms
**************************************

Overview
========
Many problems involving multi-step decision making process can be modeled as the
exploration/traversal in a tree space for a solution or solutions. There are
many algorithms to search the tree spaces depending on the problems. We
introduce two of them here.

Backtracking
============
An algorithm that incrementally build candidates toward the solution and reject
candidates as soon as it is known not to lead to a solution. It searches paths
in a decision tree space and allows early pruning of branches. When a candidate
is abandoned it **backtracks** to a prior state and search for the next
candidate.

* Try one option and search further, when done/rejected, backtrack and try next
  option
* Iterative approach uses a stack to store states
* Recursive approach implicitly uses a stack (the stack frame)
* Variations according to the goal

  - find one solution
  - find all solutions

.. backtracking-example:

Examples
--------
+ Sudoku
+ Eight queens
+ Cross-word

Exhaustive Algorithm
====================
Explore all possible combinations from a set of choices and values. Sometimes
also called recursive enumeration because it is usually implemented as recursive
structures. Iterative implementations are available too. It is often also
referred as brutal-force search.

+ Recursive
+ Helper function
+ Book-keeping parameter

.. exhaustive-example:

Examples
--------
+ Permutation
+ All binary numbers in a range
+ All decimal numbers in a range
+ Eight queens

.. backtracking-exhaustive-comp:

Comparison
==========
.. list-table:: Backtracking vs Exhaustive
  :header-rows: 1
  :stub-columns: 1
  :widths: 20 30 30

  * -
    - Backtracking
    - Exhaustive
  * - Search space
    - Generate part of the intermediate and final states
    - Generate all intermediate and final states
  * - Constraint application
    - Reject partial solutions
    - Validate final states
  * - Run-time
    - fast
    - slow
  * - Implementation
    - Stack/Recursion
    - Nested Loops/Recursion
  * - Problem type
    - find one/find all
    - usually find all
