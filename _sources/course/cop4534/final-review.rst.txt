************
Final Review
************

How to use this document
========================
+ Self-test using this document to see what concepts are challenging to you.
+ The slides are the most concise and focused document you can start with.
+ Course content website is the systematic view for tips, pitfalls.
+ Practice your ability to work on an algorithm on paper. Play with the
  visualization website to see how the algorithm works step by step.
+ Refer to the practice exam for the format of the exam and the types of
  questions.
+ Refer to the test exam for how the Honorlock will work.

Type of Questions
=================
+ True/False (TF)
+ Multiple Choice (MC)
+ Fill in the Blank (FIB)
+ Matching (MAT) - match a list of items to another list of items
+ Short Answer/Coding (SA)

Topics
======
Dynamic programming
-------------------

Graph algorithms
----------------

Probability
-----------

Randomized Algorithms
---------------------



Cross-Module Concepts
=====================
+ Algorithmic paradigms

  * Greedy

    - Optimization problems
    - Approximate algorithms

      * Exceptions: Huffman coding, Prin's, Krukal's, Dijkstra's will provide
        the best solution

    - Mostly :math:'\Theta(n)`

  * Backtracking

    - Decision/Enumeration problems (can be used for optimization problems)
    - Close to brute force with pruning

  * Divide and conquer

    - Exact algorithms
    - Distinct subproblem only (in this course)
    - Recurrence relation
    - Solve recurrence using master theorem

  * Dynamic programming

    - Exact algorithms
    - Key components

      - Overlapping subproblems
      - Optimal substructure

+ Relationship between algorithms

  * Different types of problem to solve
  * Exact vs approximate
  * Complexity (efficiency)

    - Greedy < Divide and conquer, backtracking, dynamic programming < Brute
      force

+ Problem types and algorithms to solve them

  * find one solution (decision)

    - brute force
    - backtracking
    - divide and conquer

  * find all solutions (enumeration)

    - brute force
    - backtracking
    - dynamic programming

  * find best solution (optimization)

    - greedy
    - divide and conquer
    - genetic algorithm
    - all find all methods

  * Randomized algorithms are employed in may approximate algorithms

+ Problem perspective

  * TSP

    - NP-hard: prefer approximate algorithms because exact algorithms are
      not practical
    - Circular permutation

      * :math:`\Theta(n!)` brute force

  * Bin packing

    - NP-hard: prefer approximate algorithms because exact algorithms are
      not practical
    - Online vs offline
    - Greedy: First fit, best fit, next fit
    - Permutation + next fit brute force

      - :math:`\Theta(n!)`

  * Huffman coding

    - Full binary tree
    - Prefix code
    - Greedy algorithm

  * Max sum subarray
  * Chain matrix multiplication
  * Longest common subsequence
  * Minimal spanning tree
  * Shortest path
