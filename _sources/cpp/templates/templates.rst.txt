.. highlight:: c++
  :linenothreshold: 5

****************
Templates in C++
****************
Template is a method in C++ language to generalize functions/classes to be used
with various base types. It allows a same function or class to work with
various data types.

+ E.g. STL containers like ``vector<int>``, ``vector<string>``, ``set<int>``,
  ``map<int, double>``, etc. are templates.
+ E.g. type cast functions like ``static_cast<int>(3.5)``
+ Similar idea to Java generics but with different implementation details

Alternatives
============
There are other way to allow generalization of functions to work with different
types.

+ function overloading

  * Define many functions like ``min(int, int)``, ``min(double, double)``,
    ``min(char, char)``, with a same name but different parameter types.
  * Similar logics may be repeated many times.

+ implicit type casting

  * A function ``min(double, double)`` can handle calls like ``min(2, 3)``,
    ``min(2.0, 3)``, ``min('a', 66)``, etc.
  * May cause confusion
  * Not work with complex data types

Sometimes the base types are not used as parameter types but internal
variables. In these cases, template is the only solution.

Syntax
======
+ Define a template

  * A line above the first line of a function/class declaration/definition
  * ``template<typename T>`` or ``template<class T>``
  * ``T`` refers to a user-defined name for the base type

    - known as **template argument**
    - ``T`` used as a type in the following function/class

  * Takes multiple types, e.g. ``template<typename T1, typename T2>``
  * May have a default value for the type ``template<typename T1=int>``
  * IMPORTANT! Every declaration/definition containing the ``T`` must
    have a ``template`` clause
  * The keyword ``typename`` and ``class`` in the ``template`` clause are
    interchangeable

  ::

    template<typename T>
    T func1(T param1);

    template<typename T>
    class MyClass{
     public:
      bool method1(T param1);
    }

    // important to notice that MyClass is followed by <T> here!
    // MyClass is the name of the template while MyClass<T> is the
    //     name of the class
    template<typename T>
    bool MyClass<T>::method1(T param1) {
      // core logics
      return true;
    }

+ To use a template

  * Specify the template argument to **instantiate** the template::

      // function template
      int result = func1<int>(10);

      // class template
      MyClass<int> obj1;
      if (obj1.method1(10))
        cout << "True" << endl;

  * **Template argument deduction** for function template::

      result = func1(10);  // T will be int
      result = func1<>(10);  // T will be int
      result = func1(10.0);  // T will be double

    .. note::

      Template argument deduction for class template not available until C++ 17


Split header/implementation file
================================

**TL;DR Put everything of a template in a single header file.**

A template must be instantiated to provided the compilable source code. The
instantiation of templates is lazy. Only when a templated entity is used with
base type(s) specified, the template will be instantiated. For instance,
``vector<int>`` is an instantiation of the ``vector`` template. When an
occurrence of ``vector<int>`` is seen by the compiler, the compiler will search
to see if there is a version of it. If not, the compiler will look for the
source code of the ``vector`` template and instantiate it to generate the
instance of ``vector<int>``.

- a template itself cannot be compiled
- a template must be instantiated to generate code to be compiled
- instantiation is a process to provide really parameter to a template
- when you instantiate a template in a cpp file and try to compile it, the
  compiler will look for the template to instantiate from the current cpp file,
  and all included header files, etc.
- if the template code (not instantiated) is in another cpp file, the compiler
  cannot find it and the instantiation will fail.

Thus, it is natural to have a templated function/class in a single header file
so that when a cpp file uses the template, the compiler can find all the
template code in the header. **This method is recommended in most of the
scenarios in our courses.**

If the implementation portion of a template is split into a cpp file like we
normal do with un-templated code. This portion of code cannot be found when
compiling the header with another cpp file that included the header.

There are two work-around methods when the split is preferred:

1. split implementations in a separate file and include it in the header file
   after the declarations
2. split implementations into a cpp file, declare all possible instantiations
   of the template in the cpp file; Thus, when other cpp needs to use the
   template, the instantiated codes have already been instantiated and ready
   for use.

.. _example:

Examples
========

.. code-block:: c++
   :caption: Template Syntax

    template<typename T>
    T func1(T param1);

    template<typename T>
    class MyClass{
    public:
      bool method1(T param1);
    }

    // important to notice that MyClass is followed by <T> here!
    template<typename T>
    bool MyClass<T>::method1(T param1) {
      // logics
      return true;
    }

.. literalinclude:: template-demo.hpp
  :caption: template-demo.hpp
  :language: cpp
  :linenos:

.. literalinclude:: template-test.cpp
  :caption: template-test.cpp
  :language: cpp
  :linenos:

