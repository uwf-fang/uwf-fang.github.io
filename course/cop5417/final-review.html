<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Final Review &#8212; IanFang Teaching Material Hosting  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css?v=279e0f84" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=fa3f9a06" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="https://uwf-fang.github.io/course/cop5417/final-review.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="COP 3014 Algorithm and Program Design" href="../cop3014/index.html" />
    <link rel="prev" title="Graph" href="graph.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../cop3014/index.html" title="COP 3014 Algorithm and Program Design"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Graph"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IanFang Teaching Material Hosting  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">COP 5417 Data Structure and Algorithms Essentials</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Final Review</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="final-review">
<h1>Final Review<a class="headerlink" href="#final-review" title="Link to this heading">¶</a></h1>
<section id="materials">
<h2>Materials<a class="headerlink" href="#materials" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Homeworks: same types of problems</p></li>
<li><p>Slides</p></li>
<li><p>Course note hosted on github: Checklist of topics</p></li>
<li><p>Textbook: skip the details not listed in the slides or course note</p></li>
<li><p>Visualizations: make sure that you understand how algorithms work on paper</p></li>
<li><p>Code examples: help you understand how to algorithms work</p></li>
<li><p>Projects: not too helpful to final but you can find common mistakes in your
code</p></li>
</ol>
</section>
<section id="problem-types">
<h2>Problem Types<a class="headerlink" href="#problem-types" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>True/False questions</p></li>
<li><p>Multiple choices</p></li>
<li><p>Multiple answers</p></li>
<li><p>Fill in the blanks</p></li>
<li><p>Matching</p></li>
<li><p>Coding questions</p>
<ul>
<li><p>There will be 1 or 2 coding questions. They are only for simple algorithms
that can fit in a short method. A simple algorithm should be less then 20
lines of code as a Java method. Most of the algorithms are too long to be
coded in exam and will only tested on how they work on paper.</p></li>
<li><p>They can also be a question on describing the interface of an ADT (only
list public methods) or framework of a data structure (both private and
public members).</p></li>
<li><p>I will not focus on the use of Java features like generic, interface,
inheritance, etc. You may see these features though. The coding questions
will only test your understanding of the algorithm rather than your Java
skills but you certainly need to use correct Java code to write your
answers.</p></li>
</ul>
</li>
</ul>
</section>
<section id="general-questions">
<h2>General Questions<a class="headerlink" href="#general-questions" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>For an ADT</p>
<ul>
<li><p>What is the interface/API? Required and optional parts.</p></li>
<li><p>What are the implementations? Pro and con of each implementation.</p></li>
<li><p>What are the applications of the ADT? Required in certain algorithms or
data structures? Used to solve certain problems?</p></li>
</ul>
</li>
<li><p>For a data structure</p>
<ul>
<li><p>Typical Java implementation: Usually a Java class</p></li>
<li><p>What are the components? Required and optional operations.</p></li>
<li><p>Is there any variation of the data structure? Pros and cons of each
variation.</p></li>
<li><p>What are the applications of the data structure? Required in certain
algorithms or data structures? Used to solve certain problems?</p></li>
</ul>
</li>
<li><p>For an algorithm</p>
<ul>
<li><p>Typical Java implementation: a Java class, a method in a Java class or a
static method in a Java class (correspond a standalone function)</p></li>
<li><p>What is the problem that the algorithm is trying to solve?</p></li>
<li><p>What ADTs or data structures are required by the algorithm?</p></li>
<li><p>Is this algorithm part of a data structure?</p></li>
<li><p><strong>What is the time complexity of the algorithm? What is the space
complexity of the algorithm?</strong> Big-Theta notation only.</p></li>
</ul>
</li>
</ul>
</section>
<section id="list-of-algorithms">
<h2>List of algorithms<a class="headerlink" href="#list-of-algorithms" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Must know details (how it works on paper)</p></li>
<li><p>Search in sequential data structures</p>
<ul>
<li><p>Linear search</p></li>
<li><p>Binary search</p></li>
</ul>
</li>
<li><p>Sorting algorithms</p>
<ul>
<li><p>Selection sort</p></li>
<li><p>Insertion sort</p></li>
<li><p>Merge sort</p></li>
<li><p>Quick sort</p>
<ul>
<li><p>Partition using Hoare’s scheme, first element as pivot, no initial
shuffling</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Heap data structure</p>
<ul>
<li><p>add</p></li>
<li><p>remove</p></li>
<li><p>Percolate up</p></li>
<li><p>Percolate down</p></li>
<li><p>Heapify</p></li>
<li><p>Heap sort</p></li>
</ul>
</li>
<li><p>BST</p>
<ul>
<li><p>Insert</p></li>
<li><p>Search</p></li>
<li><p>Delete - use successor to replace the node to be deleted</p></li>
</ul>
</li>
<li><p>Red-black tree</p>
<ul>
<li><p>Adjustment in insert</p>
<ul>
<li><p>How to handle</p>
<ul>
<li><p>Right-leaning red - left rotation</p></li>
<li><p>Left-left red - right rotation</p></li>
<li><p>Left-right red - left rotation + right rotation</p></li>
<li><p>Both children red - recolor</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Hash table</p>
<ul>
<li><p>Variations on collision resolution</p>
<ul>
<li><p>Separate chaining</p></li>
<li><p>Linear probing (simplest open addressing)</p></li>
</ul>
</li>
<li><p>Insert with collision resolution</p>
<ul>
<li><p>Linear probing</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Graph</p>
<ul>
<li><p>Interconversion of graph representations and graph diagrams</p>
<ul>
<li><p>Adjacency matrix</p></li>
<li><p>Adjacency list</p></li>
</ul>
</li>
<li><p>Graph traversal</p>
<ul>
<li><p>DFS</p></li>
<li><p>BFS</p></li>
</ul>
</li>
<li><p>Shortest path: Dijkstra’s algorithm</p></li>
</ul>
</li>
</ul>
</section>
<section id="topics">
<h2>Topics<a class="headerlink" href="#topics" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Basic concepts</p>
<ul>
<li><p>ADT - not language dependent</p></li>
<li><p>Data structure - usually language dependent</p></li>
<li><p>Algorithm</p></li>
<li><p>Relationship of ADT, data structure, and algorithm</p>
<ul>
<li><p>Data structure is the implementation of ADT</p></li>
<li><p>ADT is the interface/API/abstraction of data structures</p></li>
<li><p>Algorithm can be part of a data structure</p></li>
<li><p>Algorithm may require certain ADTs or data structures to work</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Algorithm analysis</p>
<ul>
<li><p>Purpose</p></li>
<li><p>Asymptotic notation</p>
<ul>
<li><p>Big-O notation: upper bound</p></li>
<li><p>Big-Omega notation: lower bound</p></li>
<li><p>Big-Theta notation: average case/exact bound, most important!</p></li>
</ul>
</li>
<li><p>Time complexity</p>
<ul>
<li><p>Constant time complexity: <span class="math notranslate nohighlight">\(\Theta(1)\)</span></p></li>
<li><p>Linear time complexity: <span class="math notranslate nohighlight">\(\Theta(n)\)</span></p>
<ul>
<li><p>Linear search, sum, max, min, average, etc.</p></li>
<li><p>Loops on N that reduce by 1 in each iteration</p></li>
</ul>
</li>
<li><p>Logarithmic time complexity: :<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span></p>
<ul>
<li><p>Binary search</p></li>
<li><p>Loops on N that reduce by half in each iteration</p></li>
<li><p>Recursion on N that reduce by half in each recursion (binary search)</p></li>
</ul>
</li>
<li><p>Quadratic time complexity: <span class="math notranslate nohighlight">\(\Theta(n^2)\)</span></p>
<ul>
<li><p>Simple sorting algorithms like bubble sort, selection sort, insertion
sort</p></li>
<li><p>Loops on N that reduce by 1 in each iteration</p></li>
<li><p>Nested loops on N that reduce by 1 in each iteration</p></li>
</ul>
</li>
<li><p>Loglinear time complexity: :<span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span></p>
<ul>
<li><p>Divide and conquer algorithms like merge sort and quick sort</p></li>
<li><p>Loops on N that reduce by half in each iteration and nested loops on
N that reduce by 1 in each iteration</p></li>
<li><p>Recursion on N that reduce by half in each recursion and nested
recursion call work on on N that reduce by 1 in each recursion</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Sequential ADTs</p>
<ul>
<li><p>Stack ADT</p>
<ul>
<li><p>LIFO</p></li>
<li><p>push/pop/peek/isEmpty</p></li>
</ul>
</li>
<li><p>Queue ADT</p>
<ul>
<li><p>FIFO</p></li>
<li><p>enqueue/dequeue/peek/isEmpty</p></li>
</ul>
</li>
<li><p>Linked-list data structure</p>
<ul>
<li><p>Node class</p></li>
<li><p>add/remove at the beginning/end in the implementation of Stack and queue</p></li>
<li><p>variation:</p>
<ul>
<li><p>singly/doubly linked-list</p></li>
<li><p>with/without tail reference</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Analysis of all operations of stack and queue</p>
<ul>
<li><p>Time complexity</p></li>
<li><p>Space complexity</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Sorting algorithms</p>
<ul>
<li><p>Role</p>
<ul>
<li><p>a method in a sequential data structure</p></li>
<li><p>a standalone static method that takes a sequential data structure as
input</p></li>
</ul>
</li>
<li><p>Categories</p>
<ul>
<li><p>Comparison based sorting algorithms (general purpose sorting algorithms)</p>
<ul>
<li><p>Bubble sort</p></li>
<li><p>Selection sort</p></li>
<li><p>Insertion sort</p></li>
<li><p>Merge sort</p></li>
<li><p>Quick sort</p></li>
</ul>
</li>
<li><p>Non-comparison based sorting algorithms</p>
<ul>
<li><p>Counting sort</p></li>
<li><p>Radix sort</p></li>
</ul>
</li>
<li><p>Simple sorting algorithms</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\Theta(n^2)\)</span> time complexity</p></li>
<li><p>Selection sort</p></li>
<li><p>Insertion sort</p></li>
</ul>
</li>
<li><p>Fast sorting algorithms</p>
<ul>
<li><p>:<span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span> time complexity</p></li>
<li><p>Merge sort</p></li>
<li><p>Quick sort</p></li>
</ul>
</li>
<li><p>Divide and conquer sorting algorithms</p>
<ul>
<li><p>Merge sort</p></li>
<li><p>Quick sort</p></li>
<li><p>Hybrid sorting algorithms</p>
<ul>
<li><p>Use divide and conquer algorithms for large subsequences</p></li>
<li><p>Use simple sorting algorithms for small subsequences</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Analysis</p>
<ul>
<li><p>Time complexity</p>
<ul>
<li><p>worst case</p></li>
<li><p>average case</p></li>
<li><p>best case</p></li>
</ul>
</li>
<li><p>Space complexity</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\Theta(1)\)</span> space complexity: in-place sorting algorithms like bubble
sort, selection sort, insertion sort, quick sort, etc.</p></li>
<li><dl class="simple">
<dt><span class="math notranslate nohighlight">\(\Theta(n)\)</span> space complexity: not-in-place algorithms like merge sort,</dt><dd><p>counting sort, radix sort, etc.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p>In-place or not</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Heap data structure</p>
<ul>
<li><p>Stored in an array (array list)</p></li>
<li><p>Logically a complete binary tree</p></li>
<li><p>Heap property</p>
<ul>
<li><p>min heap: the value of a node is smaller than or equal to the values of
its children</p></li>
<li><p>max heap: the value of a node is larger than or equal to the values of
its children</p></li>
</ul>
</li>
<li><p>Behaviors</p>
<ul>
<li><p>add: add a new element to the end of the array and percolate up/swim</p></li>
<li><p>remove: overwrite the root with the last element of the array, remove
the last element of the array, and percolate down/sink</p></li>
<li><p>peek</p></li>
<li><p>isEmpty</p></li>
<li><p><strong>percolate up/swim (private)</strong></p></li>
<li><p><strong>percolate down/sink (private)</strong></p></li>
<li><p>heapify (private)</p></li>
</ul>
</li>
<li><p>Applications</p>
<ul>
<li><p>Priority queue</p></li>
<li><p>Heap sort</p></li>
<li><p>Dijkstra’s shortest path algorithm</p></li>
<li><p>Prim’s minimum spanning tree algorithm</p></li>
<li><p>Find the kth largest element in an array</p></li>
</ul>
</li>
<li><p>Time complexity analysis</p>
<ul>
<li><p>add/remove/peek/isEmpty: :<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span></p></li>
<li><p>percolate up/swim: :<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span></p></li>
<li><p>percolate down/sink: :<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span></p></li>
<li><p>heapify: <span class="math notranslate nohighlight">\(\Theta(n)\)</span> or :<span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span></p></li>
</ul>
</li>
</ul>
</li>
<li><p>Heap sort</p>
<ul>
<li><p>Repeatedly remove the root of the heap and add it to the end of the array
until the heap is empty</p></li>
<li><p>Improved version of insertion sort</p></li>
<li><p>Time complexity: :<span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span></p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>Priority Queue ADT</p>
<ul>
<li><p>Behaviors</p>
<ul>
<li><p>enqueue</p></li>
<li><p>dequeue</p></li>
<li><p>peek</p></li>
<li><p>isEmpty</p></li>
</ul>
</li>
<li><p>Implementations</p>
<ul>
<li><p>Heap data structure</p></li>
<li><p>Array</p>
<ul>
<li><p>sorted</p></li>
<li><p>unsorted</p></li>
</ul>
</li>
<li><p>Time complexity analysis</p>
<ul>
<li><p>Heap implementation: :<span class="math notranslate nohighlight">\(\Theta(n \log n)\)</span></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p>Symbol table/map/dictionary ADT</p>
<ul>
<li><p>Key-value pairs</p>
<ul>
<li><p>Key</p>
<ul>
<li><p>unique, allows equality comparison</p></li>
<li><p>comparable</p></li>
<li><p>immutable</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Behaviors</p>
<ul>
<li><p>put</p></li>
<li><p>get</p></li>
<li><p>delete</p></li>
<li><p>contains</p></li>
<li><p>size</p></li>
<li><p>isEmpty</p></li>
</ul>
</li>
<li><p>When values are ignored, symbol table ADT degrades to a set ADT</p></li>
<li><p>Implementations:</p>
<ul>
<li><p>Sorted array/list</p></li>
<li><p>Unsorted array/list</p></li>
<li><p>Binary search tree</p></li>
<li><p>Hash table</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Tree</p>
<ul>
<li><p>concepts</p>
<ul>
<li><p>Node</p></li>
<li><p>Edge</p></li>
<li><p>Parent/child relationship</p></li>
<li><p>Ancestor/descendant relationship</p></li>
<li><p>Sibling relationship</p></li>
<li><p>Root node</p></li>
<li><p>Leaf node</p></li>
<li><p>Internal node</p></li>
<li><p>Degree</p></li>
<li><p>Path</p></li>
<li><p>Distance</p></li>
<li><p>Height of a tree</p></li>
<li><p>Depth of a node</p></li>
<li><p>Ordered tree/Unordered tree</p></li>
</ul>
</li>
<li><p>Hierarchy</p>
<ul>
<li><p>Binary tree: degree 2 ordered tree</p>
<ul>
<li><p>Heap</p></li>
<li><p>Binary search tree</p>
<ul>
<li><p>Self-balancing binary search tree</p>
<ul>
<li><p>AVL tree</p></li>
<li><p>Red-black tree</p></li>
<li><p>B-tree</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Binary search tree</p>
<ul>
<li><p>binary tree with order property</p>
<ul>
<li><p>left subtree contains only nodes with keys less than the key of the root
node</p></li>
<li><p>right subtree contains only nodes with keys greater than the key of the
root node</p></li>
<li><p>left and right subtrees are also binary search trees</p></li>
</ul>
</li>
<li><p>Behaviors</p>
<ul>
<li><p>put</p></li>
<li><p>get</p></li>
<li><p>delete</p></li>
<li><p>traversal (in-order)</p></li>
<li><p>size</p></li>
<li><p>isEmpty</p></li>
</ul>
</li>
<li><p>Time complexity analysis</p>
<ul>
<li><p>put/get/delete</p>
<ul>
<li><p>depends on the depth of the tree</p></li>
<li><p>average :<span class="math notranslate nohighlight">\(\Theta(\log n)\)</span></p></li>
<li><p>worst case <span class="math notranslate nohighlight">\(\Theta(n)\)</span></p></li>
</ul>
</li>
<li><p>size/isEmpty: <span class="math notranslate nohighlight">\(\Theta(1)\)</span></p></li>
</ul>
</li>
<li><p>Applications</p>
<ul>
<li><p>Symbol table</p></li>
<li><p>Priority queue</p></li>
<li><p>Binary search</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Self-balancing BST</p>
<ul>
<li><p>2-3 Trees</p>
<ul>
<li><p>2-node: one key, two children</p></li>
<li><p>3-node: two keys, three children</p></li>
<li><p>4-node: three keys, four children (temporary)</p></li>
<li><p>always a perfectly balanced tree</p></li>
<li><p>insert</p></li>
</ul>
</li>
<li><p>Red-black BSTs (left-leaning) to implement 2-3 trees</p>
<ul>
<li><p>Not a perfectly balanced tree</p></li>
<li><p>Left-leaning by definition</p></li>
<li><p>Behaviors</p>
<ul>
<li><p>search/contains/get -  same as BST</p></li>
<li><p>Insert</p>
<ul>
<li><p>insert like normal BST with a red link</p></li>
<li><p>adjust</p>
<ul>
<li><p>left rotation</p></li>
<li><p>right rotation</p></li>
<li><p>recolor (split)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Graph</p>
<ul>
<li><p>Concepts</p>
<ul>
<li><p>Vertex/Node</p></li>
<li><p>Edge</p></li>
<li><p>Adjacent</p></li>
<li><p>Direction</p></li>
<li><p>Path</p></li>
<li><p>Connected</p></li>
<li><p>Cycle</p></li>
<li><p>Distance</p></li>
<li><p>Weight</p></li>
<li><p>Degree</p></li>
</ul>
</li>
<li><p>Types/Properties</p>
<ul>
<li><p>Directed/Undirected</p></li>
<li><p>Cycle/Acyclic</p></li>
<li><p>Weighted/Unweighted</p></li>
<li><p>Connected/Unconnected</p></li>
<li><p>Dense/Sparse</p></li>
</ul>
</li>
<li><p>Representations</p>
<ul>
<li><p>List of edges</p></li>
<li><p>Adjacency matrix</p></li>
<li><p>Adjacency list</p></li>
<li><p>Pros and cons</p></li>
</ul>
</li>
<li><p>Time complexity analysis</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(V\)</span>, <span class="math notranslate nohighlight">\(E\)</span></p></li>
<li><p>Different among various representations</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Graph traversal</p>
<ul>
<li><p>Similar to that of tree traversal</p></li>
<li><p>Depth-first search (DFS)</p>
<ul>
<li><p>Recursive implementation</p></li>
<li><p>Iterative implementation (Stack ADT)</p></li>
</ul>
</li>
<li><p>Breadth-first search (BFS)</p>
<ul>
<li><p>Iterative implementation (Queue ADT)</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Minimal spanning tree of a graph</p>
<ul>
<li><p>Concepts</p>
<ul>
<li><p>Spanning tree</p></li>
<li><p>Minimal spanning tree (MST)</p></li>
<li><p>Weighted graph</p></li>
<li><p>Weight of a spanning tree</p></li>
</ul>
</li>
<li><p>Algorithms (greedy algorithms)</p>
<ul>
<li><p>Prim’s algorithm - grow from starting vertex</p></li>
<li><p>Kruskal’s algorithm - grow forests from edges with smallest weights and
combine to a tree</p></li>
<li><p><strong>Further details are optional in this course</strong></p></li>
</ul>
</li>
</ul>
</li>
<li><p>Shortest paths in graph</p>
<ul>
<li><p>Dijkstra’s algorithm</p>
<ul>
<li><p>Single-source shortest path</p></li>
<li><p>Weighted graph with non-negative weights</p></li>
<li><p>Requires a priority queue ADT</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Final Review</a><ul>
<li><a class="reference internal" href="#materials">Materials</a></li>
<li><a class="reference internal" href="#problem-types">Problem Types</a></li>
<li><a class="reference internal" href="#general-questions">General Questions</a></li>
<li><a class="reference internal" href="#list-of-algorithms">List of algorithms</a></li>
<li><a class="reference internal" href="#topics">Topics</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="graph.html"
                          title="previous chapter">Graph</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="../cop3014/index.html"
                          title="next chapter">COP 3014 Algorithm and Program Design</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/course/cop5417/final-review.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../cop3014/index.html" title="COP 3014 Algorithm and Program Design"
             >next</a> |</li>
        <li class="right" >
          <a href="graph.html" title="Graph"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IanFang Teaching Material Hosting  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >COP 5417 Data Structure and Algorithms Essentials</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Final Review</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright Copyright © Xingang (Ian) Fang 2022-25.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>