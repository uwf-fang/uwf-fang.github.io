.. highlight:: c++
  :linenothreshold: 5

*****************
Hash Table in C++
*****************
Hash table uses hashing to implement a data structure that maps a key to an
index so the value can be stored in the corresponding location (a bucket) in a
sequential data structure like an array.

**Quick question:** why linked-list is not a good way to store buckets in a
hash table? (Because the most frequent usage is to access by index, which is
slow with linked-list data structure)

Characteristics
===============
+ fast lookup :math:`O(1)`
+ redundant storage (certain ratio of empty buckets)

  * performance degradation

Hash function for hash tables
=============================
+ :math:`h(key)` a special type of hash function used by hash table
+ Maps a key of a certain type to an integer in a certain range :math:`1, 2,
  \ldots, size - 1`, where :math:`size` is the size of the hash table
+ Modulo arithmetic
+ Considerations

  * Deterministic
  * Fast to compute
  * Uniform distribution

Behaviors
=========
+ The hash table stores either key-value pairs or only keys
+ Behaviors (defers according to the data it stores)

  * Set a key-value pair/add a key
  * Get the value of a key/lookup a key
  * Delete a key-value pair/delete a key
  * Check size
  * Check empty
  * Rehashing (resize)

    - Create a new hash table with a larger size and copy all the elements from
      the old hash table to the new one
    - When the load factor :math:`\alpha` is too large
    - When the load factor :math:`\alpha` is too small
    - When there is a large number of tombstone buckets (open addressing)

Collision resolution
====================
Methods to handle collision when multiple keys are mapped to a same bucket.

Chaining
--------
+ each bucket is a linked-list to store multiple values (chained)
+ Nodes in the linked-list keeps key, value and next pointer
+ unlimited storage space
+ Performance degradation when over-filled
+ ``vector<vector<pair<keyType, valueType>>> hashTable`` Vector of vectors of
  pair objects.
+ ``vector<LinkedListNode<keyType, valueType> *> hashTable`` Vector of pointers
  to linked list.
+ ``LinkedListNode<keyType, valueType> ** hashTable`` One dimensional dynamic
  array of pointers to a linked list.

.. code-block:: cpp

  template <typename keyType, typename valueType>
  struct LikedListNode {
    keyType key;
    valueType value;
    LinkedListNode * next;
    LinkedListNode * prev;
  };

Open addressing
---------------
+ find another available bucket to store the value when a collision occurs
+ probing sequence: the sequence of the buckets to check when collision happens
+ Linear probing:

  :math:`(h1(key) + C_{1} * i) \% size, i = 0, 1, 2, 3 \dots size - 1`

+ quadratic probing:

  :math:`(h1(key) + C_{1} * i^2) \% size, i = 0, 1, 2, 3 \dots size - 1`

+ double hashing probing:

  :math:`(h1(key) + C_{1} * i * h2(key)) \% size, i = 0, 1, 2, 3 \dots size -
  1`

.. container:: footnote

  * :math:`h1(key)` is the primary hash function
  * :math:`h2(key)` is the secondary hash function
  * :math:`C_{1}` and :math:`C_{2}`, etc. are constants

+ lookup/insertion/removal implementation

  * each bucket keeps both key and value
  * differentiate **empty-since-start** vs **empty-after-removal**

+ ``Bucket<keyType, valueType> * hashTable`` One dimensional dynamic array of
  bucket objects.
+ ``vector<Bucket<keyType, valueType>> hashTable`` Vector of bucket objects.

.. code-block:: cpp

  template <typename keyType, typename valueType>
  struct Bucket {
    keyType key;
    valueType value;
    bool isEmpty = true;
    bool isDeleted = false;
  };

Applications
============
Hash map
--------
- implementation of the **Map ADT**
- key and value are different
- stores key-value pairs in a hash table
- key is unique (no duplication)
- behaviors

  + ``ValueType lookup(key)``
  + ``bool remove(key)``
  + ``bool set(key, value)``

Hash set
--------
- implementation of the **Set ADT**
- the key is treated as value
- stores only keys in a hash table
- key is unique (no duplication)
- behaviors

  + ``void add(value)``
  + ``void remove(value)``
  + ``bool exist(value)``
  + ``void intersect(anotherSet)``
  + ``void union(anotherSet)``

Chaining Hash Map Example
=========================

::

    class Node {
      int key;
      int value;
      Node *next;
     public:
      Node(int key, int value);
      int getKey() const;
      int getValue() const;
      void setNext(Node *next);
      Node *getNext() const;
    };

    // HashMap
    // chaining
    class HashMap {
      int capacity;
      Node **buckets;  // 1D array of pointers to linked-lists
      int hashFunction(int key);
     public:
      HashMap(int capacity = 100);
      ~HashMap();
      void set(int key, int value);
      bool remove(int key);
      int lookUp(int key);
    };


Open addressing example
=======================

::

    class Bucket {
      int key;
      int value;
      bool emptySinceStart;
      bool emptySinceRemoval;
     public:
      Bucket();
      void set(int key, int value);
      void remove();
      bool isEmptySinceStart() const;
      bool isEmptySinceRemoval() const;
      bool isEmpty() const;
      int getKey() const;
      int getValue() const;
    };

    // HashMap
    // Linear probing
    class HashMap {
      int capacity;
      Bucket *buckets;  // 1D array of buckets
      int hashFunction(int key);
      // probing algorithm
      int probe(int hash, int probed);
     public:
      HashMap(int capacity = 100);
      ~HashMap();
      bool set(int key, int value);
      bool remove(int key);
      int lookUp(int key);
    };

Hash Table Glossary
===================
.. glossary::

  Hash Table
    An associative data structure that models mapping from keys to values. It is
    usually implemented as an array. A hash function is employed to map the key
    to the index of the array element where the value is stored

  Key (hash table)
    The input to the hash function to calculate the index of the buckets in the
    hash table

  Value (hash table)
    The values stored in the buckets in tha hash table

  Collision (hash table)
    A collision occurs when multiple keys result in the same index in the array

  Collision resolution
    The approach to resolve collisions in hash tables

  Chaining
    A collision resolution approach in which every element in an array is a
    linked-list

  Open addressing
    A collision resolution approach in which an empty bucket elsewhere in the
    hash table is used when collision happens

  Probing
    The mechanism to determine the next index of bucket to check in the open
    addressing collision resolution approach

  Hash map
    An implementation of the Map ADT based on the hash table data structure

  Hash set
    An implementation of the Set ADT based on the hash table data structure
