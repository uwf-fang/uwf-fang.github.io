.. highlight:: c++
  :linenothreshold: 5

******************
Sorting Algorithms
******************

General info
============

+ Visualizations

  Due to the complexity of the sorting algorithms. Visualizations may greatly
  enhance the learning process. Below are two useful websites providing
  visualizations of common algorithms and data structures.

  * `visualgo.net <https://visualgo.net/en/sorting>`_
  * `Data Structure Visualization <https://www.cs.usfca.edu/~galles/visualization/Algorithms.html>`_

+ Categories

  All algorithms not mentioned in the book is for your information only.

  * Comparison based - Best algorithm complexity :math:`O(nlog(n))`

    - selection
    - insertion
    - bubble
    - quick
    - merge
    - shell

  * Other

    - Heap
    - Bucket
    - Radix
    - Counting

+ Complexity

  * simple :math:`O(n^{2})`: insert, selection, bubble
  * fast :math:`O(nlog(n))`: quick, merge, heap
  * linear: radix :math:`O(nk)`, bucket :math:`O(n + k)`

+ Storage Space

  * in-place

    - most sorting algorithms

  * not-in-place (out-of-place)

    - merge sort
    - bucket sort
    - radix sort

Insertion Sort
==============

Repeatedly take one element from the unsorted section and insert into the sorted
section.

+ Complexity: :math:`O(n^{2})`

Quick Sort
==========

Select one element (pivot), use this element to partition the whole list to
obtain two partitions. Repeat the same process on the two partitions
respectively.

+ Complexity: not stable

  * average :math:`O(nlog(n))`
  * worst :math:`O(n^{2})`

+ Pivot selection

  * fixed: first, last or middle
  * random

+ Partitioning algorithm

  * Hoare's Scheme (preferred)
  * Lomuto's Scheme

Merge Sort
==========

Take two sorted list and merge into a larger sorted list recursively.

+ Complexity: stable :math:`O(nlog(n))`
+ Variations

  * top-down

    - usually recursive
    - stop repetition when the size of section is 1 or 0
    - in each round

      + sort first half
      + sort second half
      + merge

  * bottom-up (not mentioned in the book)

    - usually iterative
    - merge all n size 1 sections (single element) into n/2 size 2 sections
    - merge all size 2 lists to size 4 lists
    - continue until done

Radix Sort
==========

Not comparison based. Collect elements into buckets multiple times. Dependant on
the semantic of the content. Example: use digits on each position of decimal
numbers as buckets; starting from the right most digit; collect numbers into
buckets, flatten, collect again to sort.

Implementation Notes
====================
+ Array based

  * fast access by index

+ Linked-list based

  * slow access by index
  * fast access to neighboring nodes
  * fast reconstruction of new list
  * best fit: out-of-space algorithms like merge sort and bucket sort
  * other choices: algorithms that scan through elements one by one like
    insertion sort, quick sort, bubble sort
