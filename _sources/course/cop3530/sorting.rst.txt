.. highlight:: c++
  :linenothreshold: 5

******************
Sorting Algorithms
******************

Sorting (general)
=================

.. toctree::
   :maxdepth: 2

   /general/algorithm/sorting

Insertion Sort
==============
Repeatedly take one element from the unsorted section and insert into the
sorted section.

+ Complexity: :math:`O(n^{2})` for array
+ **Efficient with linked-lists**

Quick Sort
==========
Quick sort is a highly efficient sorting algorithm that employs the
divide-and-conquer approach. It selects a pivot element from the input list,
partitions the list into two sublists based on the pivot, and recursively sorts
these sublists.

+ Quick Partitioning Algorithm

  * Not only used in quick sort, but also in other algorithms like selection
    algorithm.
  * Select one element, known as pivot, use this element to partition the whole
    list to two sections, such that all elements in the left section are less
    and equal than the pivot and all elements in the right section are greater
    than the pivot. (Assuming targeting an ascending order)
  * Algorithm variations

    - Hoare's Scheme
    - Lomuto's Scheme (FYI)

  * Pivot selection

    - fixed: first, last or middle
    - random

+ Recursive implementation

  * base case: list size is 1 or 0
  * recursive case

    - partition the list
    - sort left section
    - sort right section

+ Time Complexity

  * best, average :math:`O(nlog(n))` with even partitioning
  * worst :math:`O(n^{2})` with extremely uneven partitioning

+ Space Complexity

  * in-place swap based :math:`O(1)`

Merge Sort
==========
Take two sorted list and merge into a larger sorted list recursively.

+ Complexity: stable :math:`O(nlog(n))`
+ **Efficient with linked-lists**
+ Variations

  * top-down

    - cut a list to two halves, sort both halves first, then merge
    - usually recursive
    - stop repetition when the size of section is 1 or 0
    - in each round

      + sort first half
      + sort second half
      + sorted merge

  * bottom-up (not mentioned in the book)

    - usually iterative
    - merge all n size 1 sections (single element) into n/2 size 2 sections
    - merge all size 2 lists to size 4 lists
    - continue until done

Radix Sort
==========
Not comparison based. Collect elements into buckets multiple times. Dependant
on the semantic of the content. Example: use digits on each position of decimal
numbers as buckets; starting from the right most digit; collect numbers into
buckets, flatten, collect again to sort.

Code examples
=============
+ `Advanced sorting algorithms <3530ch9eg_>`_

.. _3530ch9eg: https://github.com/uwf-fang/cop3530-examples/tree/main/ch09-sorting
